<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Full Screen Three.js Creature</title>
    <style>
      body { margin: 0; overflow: hidden; }
    </style>
  </head>
  <body>
    <!-- Include Three.js from a CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
      let scene, camera, renderer, points, geometry, material;
      let t = 0;
      const GRID_SIZE = 200; // 200x200 grid => 40,000 points

      init();
      animate();

      function init() {
        // Create scene
        scene = new THREE.Scene();

        // Set up a perspective camera.
        // We'll adjust positions so the creature remains centered.
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
        // Position the camera far enough out so that our scene (which is centered dynamically) is visible.
        camera.position.z = 500;

        // Create renderer with full window size
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Create BufferGeometry for 40,000 points
        const numPoints = GRID_SIZE * GRID_SIZE;
        geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(numPoints * 3);
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        // Simple white points material
        material = new THREE.PointsMaterial({ color: 0xffffff, size: 1 });
        points = new THREE.Points(geometry, material);
        scene.add(points);

        // Adjust renderer on window resize
        window.addEventListener('resize', onWindowResize, false);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
        requestAnimationFrame(animate);
        // Slower time progression (original was PI/60; now reduced)
        t += Math.PI / 240;
        updatePoints();
        renderer.render(scene, camera);
      }

      function updatePoints() {
        const positions = geometry.attributes.position.array;
        const count = positions.length / 3;

        // We'll re-center the drawing based on the window dimensions.
        // Use the window center as the offset instead of fixed 200,200.
        const centerX = window.innerWidth / 2;
        const centerY = window.innerHeight / 2;
        // Scale factor: based on a 400x400 base canvas, so it fills the screen.
        const scale = Math.min(window.innerWidth, window.innerHeight) / 400;

        for (let i = 0; i < count; i++) {
          // Calculate grid coordinates
          const xVal = i % GRID_SIZE;
          const yVal = Math.floor(i / GRID_SIZE);

          // Original intermediate computations:
          const k = xVal / 8 - 12.5;
          const e = Math.cos(k) + Math.sin(yVal / 24) + Math.cos(k / 2);
          const d = Math.abs(e);
          const q = xVal / 4 + 90 + d * k * (1 + Math.cos(d * 4 - t * 2 + yVal / 72));
          const c = (yVal * e) / 594 - t / 8 + d / 6;

          // Re-map to (X,Y) positions.
          // Instead of fixed offsets (200,200), we use the window center,
          // and apply a scale factor so that the creature fits nicely.
          const X = scale * (q * Math.cos(c)) + centerX;
          const Y = scale * ((q / 2 + 99 * Math.cos(c / 2)) * Math.sin(c) + e * 6) + centerY;
          const Z = 0;

          positions[3 * i] = X;
          positions[3 * i + 1] = Y;
          positions[3 * i + 2] = Z;
        }
        geometry.attributes.position.needsUpdate = true;
      }
    </script>
  </body>
</html>
