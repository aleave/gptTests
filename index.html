<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3D Boids with Pyramid Agents</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
  </style>
</head>
<body>
  <!-- Include Three.js from a CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    let scene, camera, renderer;
    let boids = [];
    const NUM_BOIDS = 100;
    // Define a closed cubic space (centered at 0,0,0)
    const BOUNDS = 400;
    const BOUNDS_HALF = BOUNDS / 2;
    
    // Boid parameters
    const maxSpeed = 2;
    const maxForce = 0.05;
    const neighborhoodRadius = 50;
    const separationDistance = 20;

    // --- Boid Class Definition ---
    class Boid {
      constructor() {
        // Start with a random position inside the cube
        this.position = new THREE.Vector3(
          THREE.MathUtils.randFloatSpread(BOUNDS),
          THREE.MathUtils.randFloatSpread(BOUNDS),
          THREE.MathUtils.randFloatSpread(BOUNDS)
        );
        // Random initial velocity
        this.velocity = new THREE.Vector3(
          THREE.MathUtils.randFloatSpread(2),
          THREE.MathUtils.randFloatSpread(2),
          THREE.MathUtils.randFloatSpread(2)
        );
        this.acceleration = new THREE.Vector3();
        
        // Create a pyramid shape using a ConeGeometry with 4 radial segments.
        // Increase size slightly for visibility.
        const geometry = new THREE.ConeGeometry(4, 12, 4);
        // By default, ConeGeometry points upward (along +Y). Rotate it so the tip points along +Z.
        geometry.rotateX(Math.PI / 2);
        // Use DoubleSide so the pyramid is visible from any angle.
        const material = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.position.copy(this.position);
      }
      
      update() {
        // Update velocity and position
        this.velocity.add(this.acceleration);
        this.velocity.clampLength(0, maxSpeed);
        this.position.add(this.velocity);
        // Reset acceleration for the next frame
        this.acceleration.set(0, 0, 0);
        this.mesh.position.copy(this.position);
        
        // Orient the pyramid so its tip points in the direction of velocity.
        this.mesh.lookAt(this.position.clone().add(this.velocity));
        
        // Bounce off the walls of the closed cube.
        if (this.position.x > BOUNDS_HALF) {
          this.position.x = BOUNDS_HALF;
          this.velocity.x *= -1;
        }
        if (this.position.x < -BOUNDS_HALF) {
          this.position.x = -BOUNDS_HALF;
          this.velocity.x *= -1;
        }
        if (this.position.y > BOUNDS_HALF) {
          this.position.y = BOUNDS_HALF;
          this.velocity.y *= -1;
        }
        if (this.position.y < -BOUNDS_HALF) {
          this.position.y = -BOUNDS_HALF;
          this.velocity.y *= -1;
        }
        if (this.position.z > BOUNDS_HALF) {
          this.position.z = BOUNDS_HALF;
          this.velocity.z *= -1;
        }
        if (this.position.z < -BOUNDS_HALF) {
          this.position.z = -BOUNDS_HALF;
          this.velocity.z *= -1;
        }
      }
      
      applyForce(force) {
        this.acceleration.add(force);
      }
      
      // Steer toward the average heading of local boids.
      align(boids) {
        const steering = new THREE.Vector3();
        let total = 0;
        for (const other of boids) {
          const d = this.position.distanceTo(other.position);
          if (other !== this && d < neighborhoodRadius) {
            steering.add(other.velocity);
            total++;
          }
        }
        if (total > 0) {
          steering.divideScalar(total);
          steering.setLength(maxSpeed);
          steering.sub(this.velocity);
          steering.clampLength(0, maxForce);
        }
        return steering;
      }
      
      // Steer toward the average position of local boids.
      cohesion(boids) {
        const steering = new THREE.Vector3();
        let total = 0;
        for (const other of boids) {
          const d = this.position.distanceTo(other.position);
          if (other !== this && d < neighborhoodRadius) {
            steering.add(other.position);
            total++;
          }
        }
        if (total > 0) {
          steering.divideScalar(total);
          steering.sub(this.position);
          steering.setLength(maxSpeed);
          steering.sub(this.velocity);
          steering.clampLength(0, maxForce);
        }
        return steering;
      }
      
      // Steer to avoid crowding local boids.
      separation(boids) {
        const steering = new THREE.Vector3();
        let total = 0;
        for (const other of boids) {
          const d = this.position.distanceTo(other.position);
          if (other !== this && d < separationDistance) {
            const diff = new THREE.Vector3().subVectors(this.position, other.position);
            diff.divideScalar(d); // Weight by distance.
            steering.add(diff);
            total++;
          }
        }
        if (total > 0) {
          steering.divideScalar(total);
          steering.setLength(maxSpeed);
          steering.sub(this.velocity);
          steering.clampLength(0, maxForce);
        }
        return steering;
      }
      
      flock(boids) {
        const alignment = this.align(boids);
        const cohesion = this.cohesion(boids);
        const separation = this.separation(boids);
        
        // Weight the forces as desired.
        alignment.multiplyScalar(1.0);
        cohesion.multiplyScalar(0.8);
        separation.multiplyScalar(1.5);
        
        this.applyForce(alignment);
        this.applyForce(cohesion);
        this.applyForce(separation);
      }
    }

    // Initialize and animate after the Boid cl
