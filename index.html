<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Infinite Minimalistic Scroller with Action</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; }
    #instructions {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #eee;
      font-family: sans-serif;
      background: rgba(0,0,0,0.5);
      padding: 10px;
      border-radius: 4px;
      line-height: 1.5;
    }
  </style>
</head>
<body>
  <div id="instructions">
    Infinite Minimalistic Scroller with Sword Action<br>
    <strong>Controls:</strong> Left/Right Arrow or A/D to move<br>
    Press SPACE to swing your sword (destroy obstacles)
  </div>
  <!-- Include Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js"></script>
  <script>
    // --- Scene Setup ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.015);

    // Camera setup: we use Perspective and simulate forward motion
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 4, 10);
    camera.lookAt(0, 0, -20);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setClearColor(0x000000);
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
    directionalLight.position.set(0, 10, 5);
    scene.add(directionalLight);

    // --- Road (Infinite Scroller) ---
    const roadWidth = 8;
    const segmentLength = 30;
    const numSegments = 5;
    const roadSegments = [];
    const roadMaterial = new THREE.MeshBasicMaterial({
      color: 0xffffff,
      wireframe: true,
      opacity: 0.3,
      transparent: true
    });
    const roadGeometry = new THREE.PlaneGeometry(roadWidth, segmentLength, 2, 2);

    for (let i = 0; i < numSegments; i++) {
      const segment = new THREE.Mesh(roadGeometry, roadMaterial);
      segment.rotation.x = -Math.PI / 2;
      segment.position.z = -i * segmentLength;
      scene.add(segment);
      roadSegments.push(segment);
    }

    // --- Obstacles (Abstract Floating Spheres) ---
    const obstacles = [];
    const obstacleGroup = new THREE.Group();
    scene.add(obstacleGroup);

    function createAbstractObstacle(zPos) {
      const geometry = new THREE.SphereGeometry(0.8, 16, 16);
      const material = new THREE.MeshBasicMaterial({
        color: 0x00ffcc,
        wireframe: true,
        opacity: 0.6,
        transparent: true
      });
      const mesh = new THREE.Mesh(geometry, material);
      // Place randomly within road bounds and a modest vertical offset
      mesh.position.set((Math.random() - 0.5) * (roadWidth - 2), 1 + Math.random() * 2, zPos);
      obstacleGroup.add(mesh);
      obstacles.push(mesh);
    }

    // Generate initial obstacles along each segment
    for (let i = 0; i < numSegments; i++) {
      const baseZ = -i * segmentLength;
      const count = Math.floor(Math.random() * 3) + 1; // 1-3 obstacles per segment
      for (let j = 0; j < count; j++) {
        const offsetZ = Math.random() * segmentLength;
        createAbstractObstacle(baseZ - offsetZ);
      }
    }

    // --- Player Setup ---
    // The player is confined to left/right movement along the track.
    // Their z-position is kept a fixed offset behind the camera.
    const player = new THREE.Group();

    // Minimalist base (a small cube)
    const baseGeometry = new THREE.BoxGeometry(1, 1, 1);
    const baseMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
    const baseMesh = new THREE.Mesh(baseGeometry, baseMaterial);
    baseMesh.position.y = 0.5;
    player.add(baseMesh);

    // Minimalist sword: a thin, tall box. Initially invisible.
    const swordGeometry = new THREE.BoxGeometry(0.15, 1.8, 0.15);
    const swordMaterial = new THREE.MeshBasicMaterial({ color: 0xff00ff });
    const sword = new THREE.Mesh(swordGeometry, swordMaterial);
    // Position sword so its handle is near the player and blade extends forward.
    sword.position.set(0, 0.9, -0.8);
    sword.visible = false;
    player.add(sword);

    // Initial player position (confined to the track: x in [-3,3])
    player.position.set(0, 0, camera.position.z - 5);
    scene.add(player);

    // Movement parameters
    const moveSpeed = 0.3;
    const minX = -3;
    const maxX = 3;

    // Sword swing state
    let isSwinging = false;
    const swingDuration = 300; // milliseconds

    // --- Input Controls ---
    document.addEventListener('keydown', (event) => {
      switch (event.key) {
        case 'ArrowLeft':
        case 'a':
        case 'A':
          player.position.x = Math.max(minX, player.position.x - moveSpeed);
          break;
        case 'ArrowRight':
        case 'd':
        case 'D':
          player.position.x = Math.min(maxX, player.position.x + moveSpeed);
          break;
        case ' ':
          if (!isSwinging) {
            swingSword();
          }
          break;
      }
    });

    // Sword swing action: show the sword briefly and check collisions
    function swingSword() {
      isSwinging = true;
      sword.visible = true;
      // For the duration of the swing, check collisions in the animate loop.
      setTimeout(() => {
        sword.visible = false;
        isSwinging = false;
      }, swingDuration);
    }

    // --- Animation Loop ---
    const scrollSpeed = 0.15;
    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();

      // Move camera forward along the z-axis
      camera.position.z -= scrollSpeed;
      camera.lookAt(0, 0, camera.position.z - 20);

      // Keep player's z-position a fixed offset behind the camera
      player.position.z = camera.position.z - 5;

      // Recycle road segments: when a segment passes the camera, move it to the back
      roadSegments.forEach(segment => {
        if (segment.position.z - segmentLength / 2 > camera.position.z) {
          segment.position.z -= numSegments * segmentLength;
          // Optionally, generate new obstacles on this recycled segment
          const count = Math.floor(Math.random() * 3) + 1;
          for (let j = 0; j < count; j++) {
            const offsetZ = Math.random() * segmentLength;
            createAbstractObstacle(segment.position.z - offsetZ);
          }
        }
      });

      // Move obstacles (they simply stay static in z relative to the world)
      // Remove obstacles that have gone past the camera
      for (let i = obstacles.length - 1; i >= 0; i--) {
        if (obstacles[i].position.z > camera.position.z + 2) {
          obstacleGroup.remove(obstacles[i]);
          obstacles.splice(i, 1);
        }
      }

      // If sword is swinging, check for collision with obstacles
      if (isSwinging && sword.visible) {
        // Get sword's world position
        sword.updateMatrixWorld();
        const swordWorldPos = new THREE.Vector3();
        sword.getWorldPosition(swordWorldPos);
        // Use a simple distance threshold for collision
        const collisionThreshold = 1.0;
        for (let i = obstacles.length - 1; i >= 0; i--) {
          const obstaclePos = obstacles[i].position;
          if (swordWorldPos.distanceTo(obstaclePos) < collisionThreshold) {
            // "Destroy" the obstacle
            obstacleGroup.remove(obstacles[i]);
            obstacles.splice(i, 1);
          }
        }
      }

      renderer.render(scene, camera);
    }
    animate();

    // --- Handle Window Resize ---
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
