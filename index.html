<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Three.js Viz</title>
    <style>
      body { margin: 0; overflow: hidden; }
    </style>
  </head>
  <body>
    <!-- Include Three.js from a CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
      let scene, camera, renderer, points, geometry, material;
      let t = 0;
      const WIDTH = 400, HEIGHT = 400;
      const GRID_SIZE = 200; // using a 200x200 grid => 40,000 points

      init();
      animate();

      function init() {
        // Create scene and camera
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(45, WIDTH / HEIGHT, 1, 1000);
        camera.position.z = 500;
        
        // Create renderer and append to document
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(WIDTH, HEIGHT);
        document.body.appendChild(renderer.domElement);
        
        // Create BufferGeometry for points
        const numPoints = GRID_SIZE * GRID_SIZE; // 40,000 points
        geometry = new THREE.BufferGeometry();
        // Allocate a Float32Array for positions (x, y, z per point)
        const positions = new Float32Array(numPoints * 3);
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        
        // Use a simple white points material
        material = new THREE.PointsMaterial({ color: 0xffffff, size: 1 });
        
        // Create Points and add to scene
        points = new THREE.Points(geometry, material);
        scene.add(points);
      }

      function animate() {
        requestAnimationFrame(animate);
        // Increment t similar to your original code (t+=PI/60)
        t += Math.PI / 60;
        updatePoints();
        renderer.render(scene, camera);
      }

      function updatePoints() {
        const positions = geometry.attributes.position.array;
        const count = positions.length / 3;
        for (let i = 0; i < count; i++) {
          // Determine the grid coordinates:
          const xVal = i % GRID_SIZE;
          const yVal = Math.floor(i / GRID_SIZE);
          
          // Compute intermediate values following the original code:
          // k = x/8 - 12.5
          const k = xVal / 8 - 12.5;
          // e = cos(k) + sin(y/24) + cos(k/2)
          const e = Math.cos(k) + Math.sin(yVal / 24) + Math.cos(k / 2);
          // d = abs(e)
          const d = Math.abs(e);
          // q = x/4 + 90 + d*k*(1 + cos(d*4 - t*2 + y/72))
          const q = xVal / 4 + 90 + d * k * (1 + Math.cos(d * 4 - t * 2 + yVal / 72));
          // c = y*e/594 - t/8 + d/6
          const c = (yVal * e) / 594 - t / 8 + d / 6;
          
          // Compute final positions (2D from the original code; z set to 0)
          const X = q * Math.cos(c) + 200;
          const Y = (q / 2 + 99 * Math.cos(c / 2)) * Math.sin(c) + e * 6 + 200;
          const Z = 0;
          
          // Update the positions array
          positions[3 * i] = X;
          positions[3 * i + 1] = Y;
          positions[3 * i + 2] = Z;
        }
        geometry.attributes.position.needsUpdate = true;
      }
    </script>
  </body>
</html>
