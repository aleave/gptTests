<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Full Screen Three.js Creature</title>
    <style>
      body { margin: 0; overflow: hidden; }
    </style>
  </head>
  <body>
    <!-- Include Three.js from a CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
      let scene, camera, renderer, points, geometry, material;
      let t = 0;
      const GRID_SIZE = 200; // 200x200 grid => 40,000 points

      init();
      animate();

      function init() {
        // Create the scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);

        // Create an orthographic camera so that (0,0) is at the center.
        updateCamera();

        // Create renderer that fills the window
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Create BufferGeometry for 40,000 points
        const numPoints = GRID_SIZE * GRID_SIZE;
        geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(numPoints * 3);
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        // White points material (you can adjust size if needed)
        material = new THREE.PointsMaterial({ color: 0xffffff, size: 1 });
        points = new THREE.Points(geometry, material);
        scene.add(points);

        // Handle window resize
        window.addEventListener('resize', onWindowResize, false);
      }

      // Create or update the orthographic camera.
      function updateCamera() {
        // We'll use a camera with the center at 0,0.
        const aspect = window.innerWidth / window.innerHeight;
        const frustumHeight = window.innerHeight;
        const frustumWidth = window.innerWidth;
        // Orthographic camera: left, right, top, bottom, near, far.
        camera = new THREE.OrthographicCamera(
          -frustumWidth / 2, 
           frustumWidth / 2, 
           frustumHeight / 2, 
          -frustumHeight / 2, 
          -1000, 
           1000
        );
        camera.position.set(0, 0, 500);
        camera.lookAt(0, 0, 0);
      }

      function onWindowResize() {
        renderer.setSize(window.innerWidth, window.innerHeight);
        updateCamera();
      }

      function animate() {
        requestAnimationFrame(animate);
        // Increase time more slowly than before (was PI/60, now PI/240)
        t += Math.PI / 240;
        updatePoints();
        renderer.render(scene, camera);
      }

      function updatePoints() {
        const positions = geometry.attributes.position.array;
        const count = positions.length / 3;

        // We center the creature at (0,0) and scale based on the window size.
        // Here our base canvas is considered 400x400.
        const scale = Math.min(window.innerWidth, window.innerHeight) / 400;

        // Loop over our grid and compute positions
        for (let i = 0; i < count; i++) {
          const xVal = i % GRID_SIZE;
          const yVal = Math.floor(i / GRID_SIZE);

          // Original intermediate computations:
          const k = xVal / 8 - 12.5;
          const e = Math.cos(k) + Math.sin(yVal / 24) + Math.cos(k / 2);
          const d = Math.abs(e);
          const q = xVal / 4 + 90 + d * k * (1 + Math.cos(d * 4 - t * 2 + yVal / 72));
          const c = (yVal * e) / 594 - t / 8 + d / 6;

          // Re-map to (X, Y) positions using our scale factor.
          // Instead of fixed offsets (200,200), the creature is centered at (0,0).
          const X = scale * (q * Math.cos(c));
          const Y = scale * ((q / 2 + 99 * Math.cos(c / 2)) * Math.sin(c) + e * 6);
          const Z = 0;

          positions[3 * i] = X;
          positions[3 * i + 1] = Y;
          positions[3 * i + 2] = Z;
        }
        geometry.attributes.position.needsUpdate = true;
      }
    </script>
  </body>
</html>
